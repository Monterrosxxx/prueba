// Ruta: frontend/src/components/ProductsAdmin/hooks/useDataProducts.jsx
import { useState, useEffect } from "react";
import { toast } from "react-hot-toast";

/**
 * Hook personalizado mejorado para manejar toda la l√≥gica relacionada con productos
 * 
 * Funcionalidades principales:
 * - Gesti√≥n completa del estado de productos y categor√≠as
 * - Operaciones CRUD con validaciones exhaustivas
 * - Manejo de errores detallado y user-friendly
 * - Integraci√≥n optimizada con react-hook-form
 * - Control de estados de carga y UI
 * 
 * @returns {Object} Estados y funciones para gesti√≥n completa de productos
 */
const useDataProducts = () => {
  // ============ ESTADOS DE NAVEGACI√ìN ============

  /**
   * Controla qu√© pesta√±a est√° activa en la interfaz de administraci√≥n
   * - "list": Vista de tabla con todos los productos
   * - "form": Vista de formulario para crear/editar productos
   */
  const [activeTab, setActiveTab] = useState("list");

  // ============ CONFIGURACI√ìN DE API ============

  // URL base para todas las operaciones de productos
  const API = "http://localhost:4000/api/products";

  // ============ ESTADOS DEL FORMULARIO ============

  // Estados para todos los campos del formulario de productos
  const [id, setId] = useState(""); // ID del producto (para edici√≥n)
  const [name, setName] = useState(""); // Nombre del producto
  const [description, setDescription] = useState(""); // Descripci√≥n detallada
  const [price, setPrice] = useState(""); // Precio en formato string para inputs
  const [stock, setStock] = useState(0); // Cantidad en inventario
  const [categoryId, setCategoryId] = useState(""); // ID de la categor√≠a asociada
  const [isPersonalizable, setIsPersonalizable] = useState(false); // Si se puede personalizar
  const [details, setDetails] = useState(""); // Detalles adicionales del producto
  const [image, setImage] = useState(null); // Archivo de imagen seleccionado

  // ============ ESTADOS DE DATOS ============

  const [products, setProducts] = useState([]); // Lista de todos los productos
  const [loading, setLoading] = useState(true); // Estado de carga general
  const [categories, setCategories] = useState([]); // Lista de categor√≠as disponibles

  // ============ ESTADOS DE VALIDACI√ìN ============

  const [validationErrors, setValidationErrors] = useState({}); // Errores de validaci√≥n
  const [isSubmitting, setIsSubmitting] = useState(false); // Estado de env√≠o

  // ============ FUNCIONES DE UTILIDAD ============

  /**
   * Funci√≥n auxiliar para manejar respuestas HTTP del servidor
   * Maneja tanto respuestas JSON como HTML (errores del servidor)
   * Proporciona mensajes de error m√°s descriptivos
   * 
   * @param {Response} response - Objeto Response de fetch
   * @returns {Promise<Object>} Datos parseados de la respuesta
   * @throws {Error} Error con mensaje descriptivo si la respuesta no es v√°lida
   */
  const handleResponse = async (response) => {
    const contentType = response.headers.get('content-type');

    // Verificar que la respuesta sea JSON v√°lido
    if (!contentType || !contentType.includes('application/json')) {
      const textResponse = await response.text();
      console.error('‚ùå Respuesta no es JSON:', textResponse);
      throw new Error(`El servidor devolvi√≥ HTML en lugar de JSON. Status: ${response.status}`);
    }

    const data = await response.json();

    // Verificar si la respuesta HTTP fue exitosa
    if (!response.ok) {
      // Extraer mensaje de error espec√≠fico del backend
      const errorMessage = data.error || data.message || `Error ${response.status}`;
      throw new Error(errorMessage);
    }

    return data;
  };

  /**
   * Valida los datos del producto antes de enviar al servidor
   * Realiza validaciones exhaustivas del lado cliente
   * 
   * @param {Object} productData - Datos del producto a validar
   * @returns {Object} { isValid: boolean, errors: Object }
   */
  const validateProductData = (productData) => {
    const errors = {};

    // Validaci√≥n de nombre (obligatorio, longitud m√≠nima)
    if (!productData.name || !productData.name.trim()) {
      errors.name = "El nombre del producto es obligatorio";
    } else if (productData.name.trim().length < 2) {
      errors.name = "El nombre debe tener al menos 2 caracteres";
    } else if (productData.name.trim().length > 100) {
      errors.name = "El nombre no puede exceder 100 caracteres";
    }

    // Validaci√≥n de descripci√≥n (obligatorio, longitud m√≠nima)
    if (!productData.description || !productData.description.trim()) {
      errors.description = "La descripci√≥n del producto es obligatoria";
    } else if (productData.description.trim().length < 10) {
      errors.description = "La descripci√≥n debe tener al menos 10 caracteres";
    } else if (productData.description.trim().length > 500) {
      errors.description = "La descripci√≥n no puede exceder 500 caracteres";
    }

    // Validaci√≥n de precio (obligatorio, num√©rico, positivo)
    if (!productData.price) {
      errors.price = "El precio es obligatorio";
    } else {
      const priceValue = parseFloat(productData.price);
      if (isNaN(priceValue)) {
        errors.price = "El precio debe ser un n√∫mero v√°lido";
      } else if (priceValue <= 0) {
        errors.price = "El precio debe ser mayor a 0";
      } else if (priceValue > 999999.99) {
        errors.price = "El precio no puede exceder $999,999.99";
      }
    }

    // Validaci√≥n de stock (obligatorio, entero, no negativo)
    if (productData.stock === undefined || productData.stock === null || productData.stock === '') {
      errors.stock = "El stock es obligatorio";
    } else {
      const stockValue = parseInt(productData.stock);
      if (isNaN(stockValue)) {
        errors.stock = "El stock debe ser un n√∫mero entero";
      } else if (stockValue < 0) {
        errors.stock = "El stock no puede ser negativo";
      } else if (stockValue > 999999) {
        errors.stock = "El stock no puede exceder 999,999 unidades";
      }
    }

    // Validaci√≥n de categor√≠a (obligatorio)
    if (!productData.categoryId || !productData.categoryId.trim()) {
      errors.categoryId = "Debe seleccionar una categor√≠a";
    }

    // Validaci√≥n de imagen (obligatorio para productos nuevos)
    if (!id && !productData.image) {
      errors.image = "La imagen del producto es obligatoria";
    } else if (productData.image && productData.image instanceof File) {
      // Validar tama√±o de archivo (m√°ximo 5MB)
      if (productData.image.size > 5 * 1024 * 1024) {
        errors.image = "La imagen no puede exceder 5MB";
      }

      // Validar tipo de archivo
      const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
      if (!validTypes.includes(productData.image.type)) {
        errors.image = "La imagen debe ser JPG, PNG, WebP o GIF";
      }
    }

    // Validaci√≥n de detalles (opcional, pero con l√≠mite de caracteres)
    if (productData.details && productData.details.length > 1000) {
      errors.details = "Los detalles no pueden exceder 1000 caracteres";
    }

    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  };

  // ============ FUNCIONES DE CARGA DE DATOS ============

  /**
   * Carga todas las categor√≠as disponibles desde el servidor
   * Maneja tanto la nueva estructura de respuesta como la anterior
   */
  const fetchCategories = async () => {
    try {
      console.log('üìÇ Cargando categor√≠as...');
      const response = await fetch("http://localhost:4000/api/categories");
      const data = await handleResponse(response);

      // Manejar nueva estructura de respuesta { success, data, message }
      if (data.success && Array.isArray(data.data)) {
        console.log(`‚úÖ ${data.data.length} categor√≠as cargadas`);
        setCategories(data.data);
      } else if (Array.isArray(data)) {
        // Retrocompatibilidad con controladores antiguos
        console.log(`‚úÖ ${data.length} categor√≠as cargadas (formato anterior)`);
        setCategories(data);
      } else {
        console.warn("‚ö†Ô∏è Estructura de respuesta de categor√≠as inesperada:", data);
        setCategories([]);
      }
    } catch (error) {
      toast.error("Error al cargar las categor√≠as");
      console.error("‚ùå Error al cargar categor√≠as:", error);
      setCategories([]); // Fallback a array vac√≠o
    }
  };

  /**
   * Carga todos los productos desde el servidor
   * Maneja diferentes estructuras de respuesta y estados de error
   */
  const fetchProducts = async () => {
    try {
      setLoading(true);
      console.log('üì¶ Cargando productos...');

      const response = await fetch(API);
      const data = await handleResponse(response);

      // Manejar nueva estructura de respuesta del controlador
      if (data.success && Array.isArray(data.data)) {
        setProducts(data.data);
        console.log(`‚úÖ ${data.data.length} productos cargados exitosamente`);
      } else if (Array.isArray(data)) {
        // Retrocompatibilidad con controladores que devuelven array directo
        setProducts(data);
        console.log(`‚úÖ ${data.length} productos cargados (formato anterior)`);
      } else {
        console.warn("‚ö†Ô∏è Estructura de respuesta de productos inesperada:", data);
        setProducts([]);
      }
    } catch (error) {
      toast.error("Error al cargar los productos");
      console.error("‚ùå Error al cargar productos:", error);
      setProducts([]); // Fallback a array vac√≠o
    } finally {
      setLoading(false);
    }
  };

  // ============ EFECTO DE INICIALIZACI√ìN ============

  /**
   * Efecto que se ejecuta una vez al montar el componente
   * Carga datos iniciales de productos y categor√≠as
   */
  useEffect(() => {
    console.log('üöÄ Inicializando hook de productos...');
    fetchProducts();
    fetchCategories();
  }, []);

  // ============ FUNCIONES DE UTILIDAD DEL FORMULARIO ============

  /**
   * Limpia todos los campos del formulario y resetea el estado
   * Se usa despu√©s de crear/editar productos exitosamente
   */
  const resetForm = () => {
    console.log('üßπ Limpiando formulario de productos');
    setId("");
    setName("");
    setDescription("");
    setPrice("");
    setStock(0);
    setCategoryId("");
    setIsPersonalizable(false);
    setDetails("");
    setImage(null);
    setValidationErrors({});
  };

  // ============ FUNCI√ìN PARA CREAR PRODUCTO ============

  /**
   * Crea un nuevo producto en el servidor
   * Incluye validaciones exhaustivas y manejo de archivos
   * 
   * @param {Object} productData - Datos del producto a crear
   */
  const createProduct = async (productData) => {
    console.log('‚ûï Iniciando creaci√≥n de producto...');

    // ---- Validar datos antes de enviar ----
    const validation = validateProductData(productData);
    if (!validation.isValid) {
      console.log('‚ùå Validaci√≥n fallida:', validation.errors);
      setValidationErrors(validation.errors);
      toast.error("Por favor corrige los errores en el formulario");
      return;
    }

    try {
      setIsSubmitting(true);
      setValidationErrors({});

      // ---- Preparar datos para env√≠o ----
      const formData = new FormData();
      formData.append("name", productData.name.trim());
      formData.append("description", productData.description.trim());
      formData.append("price", parseFloat(productData.price));
      formData.append("stock", parseInt(productData.stock) || 0);
      formData.append("categoryId", productData.categoryId);
      formData.append("isPersonalizable", productData.isPersonalizable ? "true" : "false");
      formData.append("details", productData.details || "");

      // Agregar imagen si existe
      if (productData.image) {
        formData.append("images", productData.image);
      }

      console.log('üì§ Enviando producto al servidor...');

      // ---- Enviar petici√≥n POST ----
      const res = await fetch("http://localhost:4000/api/products", {
        method: "POST",
        body: formData // FormData maneja autom√°ticamente el Content-Type
      });

      const data = await handleResponse(res);

      // ---- Procesar respuesta exitosa ----
      const newProduct = data.success ? data.data : data;

      // Enriquecer producto con informaci√≥n de categor√≠a
      const categoryInfo = categories.find(cat => cat._id === productData.categoryId);
      const enrichedProduct = {
        ...newProduct,
        categoryId: categoryInfo ? {
          _id: categoryInfo._id,
          name: categoryInfo.name
        } : newProduct.categoryId
      };

      // Actualizar lista local de productos
      setProducts((prev) => [...prev, enrichedProduct]);

      // Mostrar mensaje de √©xito
      const successMessage = data.success ? data.message : "Producto creado exitosamente";
      toast.success(successMessage);

      // Limpiar formulario y volver a la lista
      resetForm();
      setActiveTab("list");

      console.log('‚úÖ Producto creado exitosamente');
    } catch (error) {
      console.error("‚ùå Error completo:", error);
      toast.error(error.message || "Error inesperado");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ============ FUNCI√ìN PARA ELIMINAR PRODUCTO ============

  /**
   * Elimina un producto espec√≠fico del servidor
   * 
   * @param {string} id - ID del producto a eliminar
   */
  const deleteProduct = async (id) => {
    try {
      console.log(`üóëÔ∏è Eliminando producto ID: ${id}`);

      const res = await fetch(`${API}/${id}`, {
        method: "DELETE"
      });

      const data = await handleResponse(res);

      // Mostrar mensaje de √©xito
      const successMessage = data.success ? data.message : "Producto eliminado";
      toast.success(successMessage);

      // Recargar lista de productos
      fetchProducts();

      console.log('‚úÖ Producto eliminado exitosamente');
    } catch (error) {
      toast.error(error.message || "Error al eliminar producto");
      console.error("‚ùå Error al eliminar:", error);
    }
  };

  // ============ FUNCI√ìN PARA PREPARAR EDICI√ìN ============

  /**
   * Prepara el formulario para editar un producto existente
   * Llena todos los campos con los datos actuales del producto
   * 
   * @param {Object} product - Objeto del producto a editar
   */
  const updateProduct = (product) => {
    console.log("üìù Preparando edici√≥n de producto:", product);
    console.log("üÜî ID del producto:", product._id);

    // ---- Llenar todos los campos del formulario ----
    setId(product._id);
    setName(product.name);
    setDescription(product.description);
    setPrice(product.price.toString()); // Convertir a string para inputs
    setStock(product.stock || 0);
    setCategoryId(product.categoryId._id || product.categoryId || "");
    setIsPersonalizable(product.isPersonalizable || false);
    setDetails(product.details || "");
    setImage(null); // Resetear imagen (se mostrar√° la actual en el preview)
    setValidationErrors({}); // Limpiar errores de validaci√≥n

    // Cambiar a la pesta√±a de formulario
    setActiveTab("form");

    console.log('‚úÖ Formulario preparado para edici√≥n');
  };

  // ============ FUNCI√ìN PARA GUARDAR EDICI√ìN ============

  /**
   * Guarda los cambios de un producto editado en el servidor
   * Maneja tanto actualizaciones con nuevas im√°genes como solo texto
   * 
   * @param {Object} productData - Datos actualizados del producto
   */
  const handleEdit = async (productData) => {
    console.log(`üíæ Guardando cambios en producto ID: ${id}`);

    // ---- Validar datos antes de enviar ----
    const validation = validateProductData(productData);
    if (!validation.isValid) {
      console.log('‚ùå Validaci√≥n fallida:', validation.errors);
      setValidationErrors(validation.errors);
      toast.error("Por favor corrige los errores en el formulario");
      return;
    }

    // ---- Verificar que existe el ID ----
    if (!id) {
      console.error("‚ùå ID del producto no encontrado. ID actual:", id);
      toast.error("ID del producto no encontrado");
      return;
    }

    console.log(`üì§ Actualizando producto en: ${API}/${id}`);

    try {
      setIsSubmitting(true);
      setValidationErrors({});

      let res;

      // ---- Determinar tipo de actualizaci√≥n ----
      if (productData.image instanceof File) {
        // Caso 1: Nueva imagen seleccionada - usar FormData
        console.log('üìÅ Actualizando con nueva imagen');

        const formData = new FormData();
        formData.append("name", productData.name.trim());
        formData.append("description", productData.description.trim());
        formData.append("price", parseFloat(productData.price));
        formData.append("stock", parseInt(productData.stock) || 0);
        formData.append("categoryId", productData.categoryId);
        formData.append("isPersonalizable", productData.isPersonalizable ? "true" : "false");
        formData.append("details", productData.details || "");
        formData.append("images", productData.image);

        res = await fetch(`${API}/${id}`, {
          method: "PUT",
          body: formData,
        });
      } else {
        // Caso 2: Solo actualizaci√≥n de texto - usar JSON
        console.log('üìù Actualizando solo datos de texto');

        const body = {
          name: productData.name.trim(),
          description: productData.description.trim(),
          price: parseFloat(productData.price),
          stock: parseInt(productData.stock) || 0,
          categoryId: productData.categoryId,
          isPersonalizable: productData.isPersonalizable,
          details: productData.details || "",
        };

        res = await fetch(`${API}/${id}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
      }

      // ---- Logging de debugging ----
      console.log("üìä Response status:", res.status);
      console.log("üìã Response URL:", res.url);

      const data = await handleResponse(res);

      // ---- Manejar √©xito ----
      const successMessage = data.success ? data.message : "Producto actualizado";
      toast.success(successMessage);

      // Limpiar formulario y volver a la lista
      resetForm();
      setActiveTab("list");
      fetchProducts(); // Recargar lista

      console.log('‚úÖ Producto actualizado exitosamente');
    } catch (error) {
      console.error("‚ùå Error completo:", error);
      toast.error(error.message || "Error al editar producto");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ============ RETORNO DEL HOOK ============

  /**
   * Retorna todos los estados y funciones necesarias para manejar productos
   * Los componentes que usen este hook tendr√°n acceso completo a la funcionalidad
   */
  return {
    // ---- Estados de navegaci√≥n ----
    activeTab,              // Pesta√±a activa ("list" o "form")
    setActiveTab,           // Funci√≥n para cambiar de pesta√±a

    // ---- Estados del formulario ----
    id,                     // ID del producto (para edici√≥n)
    name,                   // Nombre del producto
    setName,                // Funci√≥n para actualizar nombre
    description,            // Descripci√≥n del producto
    setDescription,         // Funci√≥n para actualizar descripci√≥n
    price,                  // Precio del producto (string)
    setPrice,               // Funci√≥n para actualizar precio
    stock,                  // Stock/inventario del producto
    setStock,               // Funci√≥n para actualizar stock
    categoryId,             // ID de la categor√≠a seleccionada
    setCategoryId,          // Funci√≥n para actualizar categor√≠a
    isPersonalizable,       // Si el producto es personalizable
    setIsPersonalizable,    // Funci√≥n para toggle personalizable
    details,                // Detalles adicionales del producto
    setDetails,             // Funci√≥n para actualizar detalles
    image,                  // Imagen seleccionada (File o URL)
    setImage,               // Funci√≥n para actualizar imagen

    // ---- Estados de datos ----
    products,               // Array de todos los productos
    loading,                // Estado de carga booleano
    categories,             // Array de categor√≠as disponibles

    // ---- Estados de validaci√≥n ----
    validationErrors,       // Errores de validaci√≥n actuales
    setValidationErrors,    // Funci√≥n para establecer errores
    isSubmitting,           // Estado de env√≠o del formulario

    // ---- Funciones de operaciones CRUD ----
    createProduct,          // Crear nuevo producto
    deleteProduct,          // Eliminar producto existente
    updateProduct,          // Preparar edici√≥n de producto
    handleEdit,             // Guardar cambios en producto editado

    // ---- Funci√≥n de utilidad ----
    resetForm,              // Limpiar formulario manualmente
    validateProductData,    // Funci√≥n de validaci√≥n externa
  };
};

export default useDataProducts;